drop table if exists public.groups cascade;
create table public.groups (
	id 				 bigint generated by default as identity 
						 (minvalue 0 start with 0 increment by 1) primary key,
	name 			 varchar(48) not null,
	is_trashed boolean not null,
	user_id uuid references auth.users on delete cascade not null
);

drop table if exists public.notes;
create table public.notes (
	id         bigint generated by default as identity
		         (minvalue 0 start with 0 increment by 1) primary key,
	name       varchar(48) not null,
	content 	 text not null,
	is_trashed boolean not null,
	group_id   bigint references public.groups on delete cascade not null,
	user_id uuid references auth.users on delete cascade not null
);

-- SECURE THE TABLES
alter table public.groups enable row level security;
alter table public.notes enable row level security;
-- groups
create policy "User can access own groups" on public.groups for select using ( auth.uid() = user_id);
create policy "User can insert own groups" on public.groups for insert with check ( auth.uid() = user_id);
create policy "User can update own groups" on public.groups for update using ( auth.uid() = user_id);
create policy "User can delete own groups" on public.groups for delete using ( auth.uid() = user_id);
-- notes
create policy "User can access own notes" on public.notes for select using ( auth.uid() = user_id);
create policy "User can insert own notes" on public.notes for insert with check ( auth.uid() = user_id);
create policy "User can update own notes" on public.notes for update using ( auth.uid() = user_id);
create policy "User can delete own notes" on public.notes for delete using ( auth.uid() = user_id);

create function public.set_user_id()
returns trigger as $$
begin
	if auth.uid() is not null then
		new.user_id := auth.uid();
	end if;

	return new;
end;
$$ language plpgsql;

create trigger groups_set_user_id
	before insert on public.groups
	for each row execute procedure public.set_user_id();

create trigger notes_set_user_id
	before insert on public.notes
	for each row execute procedure public.set_user_id();

-- seed data. replace user_id with one of a registered user
insert into
	groups (name, is_trashed, user_id)
values
	('group A', false, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('group B', false, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('group C', true, 'e92a8280-9d20-4dd9-9c0f-40c441810c41');

insert into
	notes (name, content, group_id, is_trashed, user_id)
values
	('note 1', 'content 1', 0, false, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('note 2', 'content 2', 1, false, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('note 3', 'content 3', 2, true, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('note 4', 'content 4', 1, true, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('note 5', 'content 5', 0, true, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('note 6', 'content 6', 1, false, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('note 7', 'content 7', 1, true, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
  ('note 8', 'content 8', 2, true, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('note 9', 'content 9', 2, true, 'e92a8280-9d20-4dd9-9c0f-40c441810c41'),
	('note 10', 'content 10', 0, false, 'e92a8280-9d20-4dd9-9c0f-40c441810c41');
